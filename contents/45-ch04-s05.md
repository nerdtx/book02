---

## Section 5: Nesting Data Structures

So far, you’ve worked with lists and dictionaries separately. But in
real-world programming, you’ll often need to combine them — for example,
storing a list of users (each represented as a dictionary), or a dictionary
where one of the values is a list of items.

This is called **nesting** data structures — putting one inside another — and
it’s a powerful way to organize complex information.

---

### Lists of Dictionaries

This is one of the most common patterns: a list of dictionary objects.

```python
contacts = [
    {"name": "Ada", "email": "ada@example.com"},
    {"name": "Linus", "email": "linus@example.com"}
]
```

You can loop through the list and access each dictionary:

```python
for contact in contacts:
    print(contact["name"], "-", contact["email"])
```

You can also modify individual entries:

```python
contacts[0]["email"] = "ada.lovelace@code.org"
```

This example would work on the first dictionary (located at index 0), replacing
the email value.

---

### Dictionary of Lists

Sometimes a dictionary will contain lists as values:

```python
inventory = {
    "fruits": ["apple", "banana", "cherry"],
    "vegetables": ["carrot", "broccoli"]
}
```

You might want to access and loop through a specific category:

```python
for item in inventory["fruits"]:
    print(item)
```

You can also modify the lists:

```python
inventory["vegetables"].append("spinach")
```

Let's break down that last example.  You could write it another way.

```python
veggie_list = inventory["vegetables"]
veggie_list.append("spinach")
```

There's something happening here that's a bit magical.  The new variable,
`veggie_list` is actually pointing to the exact same list that is in the
`inventory` dictionary, which means changing `veggie_list` also changes that
list in the `inventory`.

---

### Nested Access

When structures are nested, you access inner values step by step:

```python
users = [
    {"username": "ada", "tags": ["math", "coding"]},
    {"username": "charles", "tags": ["engineering"]}
]

print(users[1]["tags"][0])  # "engineering"
```

This means:

* `users[1]` → get the second user
* `["tags"]` → get their tag list
* `[0]` → get the first tag

---

### Real-World Example: Form Submissions

You might collect and store form responses like this:

```python
submissions = []

def submit_form(name, email):
    entry = {"name": name, "email": email}
    submissions.append(entry)
```

This pattern — appending a dictionary to a list — is used constantly in backend
programming for storing user data, logs, records, and more.

This example also introduces a new concept we will revisit later: outer scoping.
The `submissions` variable was not created inside the `submit_form` function,
therefore it is technically not a locally scoped variable.

---

### Practice Challenge

Write a script that:

1. Creates an empty list called `books`
2. Adds 3 books as dictionaries with keys: `title`, `author`, and `year`
3. Loops through the list and prints the book info in a readable format

Bonus: Ask the user to input book info and store it in the list.

---

In the next section, you’ll build a full mini-application that uses functions,
lists, and dictionaries together — a **command-line contact book** that
simulates real backend logic.

